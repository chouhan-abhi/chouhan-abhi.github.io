{"version":3,"file":"static/js/608.ed52b896.chunk.js","mappings":"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","sources":["../node_modules/diff/libesm/diff/base.js","../node_modules/diff/libesm/util/string.js","../node_modules/diff/libesm/diff/word.js","../node_modules/diff/libesm/diff/line.js","Components/DiffEditor.jsx"],"sourcesContent":["export default class Diff {\n    diff(oldStr, newStr, \n    // Type below is not accurate/complete - see above for full possibilities - but it compiles\n    options = {}) {\n        let callback;\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        else if ('callback' in options) {\n            callback = options.callback;\n        }\n        // Allow subclasses to massage the input prior to running\n        const oldString = this.castInput(oldStr, options);\n        const newString = this.castInput(newStr, options);\n        const oldTokens = this.removeEmpty(this.tokenize(oldString, options));\n        const newTokens = this.removeEmpty(this.tokenize(newString, options));\n        return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);\n    }\n    diffWithOptionsObj(oldTokens, newTokens, options, callback) {\n        var _a;\n        const done = (value) => {\n            value = this.postProcess(value, options);\n            if (callback) {\n                setTimeout(function () { callback(value); }, 0);\n                return undefined;\n            }\n            else {\n                return value;\n            }\n        };\n        const newLen = newTokens.length, oldLen = oldTokens.length;\n        let editLength = 1;\n        let maxEditLength = newLen + oldLen;\n        if (options.maxEditLength != null) {\n            maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n        }\n        const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;\n        const abortAfterTimestamp = Date.now() + maxExecutionTime;\n        const bestPath = [{ oldPos: -1, lastComponent: undefined }];\n        // Seed editLength = 0, i.e. the content starts with the same values\n        let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);\n        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n            // Identity per the equality and tokenizer\n            return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));\n        }\n        // Once we hit the right edge of the edit graph on some diagonal k, we can\n        // definitely reach the end of the edit graph in no more than k edits, so\n        // there's no point in considering any moves to diagonal k+1 any more (from\n        // which we're guaranteed to need at least k+1 more edits).\n        // Similarly, once we've reached the bottom of the edit graph, there's no\n        // point considering moves to lower diagonals.\n        // We record this fact by setting minDiagonalToConsider and\n        // maxDiagonalToConsider to some finite value once we've hit the edge of\n        // the edit graph.\n        // This optimization is not faithful to the original algorithm presented in\n        // Myers's paper, which instead pointlessly extends D-paths off the end of\n        // the edit graph - see page 7 of Myers's paper which notes this point\n        // explicitly and illustrates it with a diagram. This has major performance\n        // implications for some common scenarios. For instance, to compute a diff\n        // where the new text simply appends d characters on the end of the\n        // original text of length n, the true Myers algorithm will take O(n+d^2)\n        // time while this optimization needs only O(n+d) time.\n        let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;\n        // Main worker method. checks all permutations of a given edit length for acceptance.\n        const execEditLength = () => {\n            for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n                let basePath;\n                const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];\n                if (removePath) {\n                    // No one else is going to attempt to use this value, clear it\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath - 1] = undefined;\n                }\n                let canAdd = false;\n                if (addPath) {\n                    // what newPos will be after we do an insertion:\n                    const addPathNewPos = addPath.oldPos - diagonalPath;\n                    canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n                }\n                const canRemove = removePath && removePath.oldPos + 1 < oldLen;\n                if (!canAdd && !canRemove) {\n                    // If this path is a terminal then prune\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath] = undefined;\n                    continue;\n                }\n                // Select the diagonal that we want to branch from. We select the prior\n                // path whose position in the old string is the farthest from the origin\n                // and does not pass the bounds of the diff graph\n                if (!canRemove || (canAdd && removePath.oldPos < addPath.oldPos)) {\n                    basePath = this.addToPath(addPath, true, false, 0, options);\n                }\n                else {\n                    basePath = this.addToPath(removePath, false, true, 1, options);\n                }\n                newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);\n                if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n                    // If we have hit the end of both strings, then we are done\n                    return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;\n                }\n                else {\n                    bestPath[diagonalPath] = basePath;\n                    if (basePath.oldPos + 1 >= oldLen) {\n                        maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n                    }\n                    if (newPos + 1 >= newLen) {\n                        minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n                    }\n                }\n            }\n            editLength++;\n        };\n        // Performs the length of edit iteration. Is a bit fugly as this has to support the\n        // sync and async mode which is never fun. Loops over execEditLength until a value\n        // is produced, or until the edit length exceeds options.maxEditLength (if given),\n        // in which case it will return undefined.\n        if (callback) {\n            (function exec() {\n                setTimeout(function () {\n                    if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n                        return callback(undefined);\n                    }\n                    if (!execEditLength()) {\n                        exec();\n                    }\n                }, 0);\n            }());\n        }\n        else {\n            while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n                const ret = execEditLength();\n                if (ret) {\n                    return ret;\n                }\n            }\n        }\n    }\n    addToPath(path, added, removed, oldPosInc, options) {\n        const last = path.lastComponent;\n        if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: last.count + 1, added: added, removed: removed, previousComponent: last.previousComponent }\n            };\n        }\n        else {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: 1, added: added, removed: removed, previousComponent: last }\n            };\n        }\n    }\n    extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {\n        const newLen = newTokens.length, oldLen = oldTokens.length;\n        let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;\n        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {\n            newPos++;\n            oldPos++;\n            commonCount++;\n            if (options.oneChangePerToken) {\n                basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };\n            }\n        }\n        if (commonCount && !options.oneChangePerToken) {\n            basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };\n        }\n        basePath.oldPos = oldPos;\n        return newPos;\n    }\n    equals(left, right, options) {\n        if (options.comparator) {\n            return options.comparator(left, right);\n        }\n        else {\n            return left === right\n                || (!!options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n        }\n    }\n    removeEmpty(array) {\n        const ret = [];\n        for (let i = 0; i < array.length; i++) {\n            if (array[i]) {\n                ret.push(array[i]);\n            }\n        }\n        return ret;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    castInput(value, options) {\n        return value;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    tokenize(value, options) {\n        return Array.from(value);\n    }\n    join(chars) {\n        // Assumes ValueT is string, which is the case for most subclasses.\n        // When it's false, e.g. in diffArrays, this method needs to be overridden (e.g. with a no-op)\n        // Yes, the casts are verbose and ugly, because this pattern - of having the base class SORT OF\n        // assume tokens and values are strings, but not completely - is weird and janky.\n        return chars.join('');\n    }\n    postProcess(changeObjects, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        return changeObjects;\n    }\n    get useLongestToken() {\n        return false;\n    }\n    buildValues(lastComponent, newTokens, oldTokens) {\n        // First we convert our linked list of components in reverse order to an\n        // array in the right order:\n        const components = [];\n        let nextComponent;\n        while (lastComponent) {\n            components.push(lastComponent);\n            nextComponent = lastComponent.previousComponent;\n            delete lastComponent.previousComponent;\n            lastComponent = nextComponent;\n        }\n        components.reverse();\n        const componentLen = components.length;\n        let componentPos = 0, newPos = 0, oldPos = 0;\n        for (; componentPos < componentLen; componentPos++) {\n            const component = components[componentPos];\n            if (!component.removed) {\n                if (!component.added && this.useLongestToken) {\n                    let value = newTokens.slice(newPos, newPos + component.count);\n                    value = value.map(function (value, i) {\n                        const oldValue = oldTokens[oldPos + i];\n                        return oldValue.length > value.length ? oldValue : value;\n                    });\n                    component.value = this.join(value);\n                }\n                else {\n                    component.value = this.join(newTokens.slice(newPos, newPos + component.count));\n                }\n                newPos += component.count;\n                // Common case\n                if (!component.added) {\n                    oldPos += component.count;\n                }\n            }\n            else {\n                component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));\n                oldPos += component.count;\n            }\n        }\n        return components;\n    }\n}\n","export function longestCommonPrefix(str1, str2) {\n    let i;\n    for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[i] != str2[i]) {\n            return str1.slice(0, i);\n        }\n    }\n    return str1.slice(0, i);\n}\nexport function longestCommonSuffix(str1, str2) {\n    let i;\n    // Unlike longestCommonPrefix, we need a special case to handle all scenarios\n    // where we return the empty string since str1.slice(-0) will return the\n    // entire string.\n    if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {\n        return '';\n    }\n    for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {\n            return str1.slice(-i);\n        }\n    }\n    return str1.slice(-i);\n}\nexport function replacePrefix(string, oldPrefix, newPrefix) {\n    if (string.slice(0, oldPrefix.length) != oldPrefix) {\n        throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);\n    }\n    return newPrefix + string.slice(oldPrefix.length);\n}\nexport function replaceSuffix(string, oldSuffix, newSuffix) {\n    if (!oldSuffix) {\n        return string + newSuffix;\n    }\n    if (string.slice(-oldSuffix.length) != oldSuffix) {\n        throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);\n    }\n    return string.slice(0, -oldSuffix.length) + newSuffix;\n}\nexport function removePrefix(string, oldPrefix) {\n    return replacePrefix(string, oldPrefix, '');\n}\nexport function removeSuffix(string, oldSuffix) {\n    return replaceSuffix(string, oldSuffix, '');\n}\nexport function maximumOverlap(string1, string2) {\n    return string2.slice(0, overlapCount(string1, string2));\n}\n// Nicked from https://stackoverflow.com/a/60422853/1709587\nfunction overlapCount(a, b) {\n    // Deal with cases where the strings differ in length\n    let startA = 0;\n    if (a.length > b.length) {\n        startA = a.length - b.length;\n    }\n    let endB = b.length;\n    if (a.length < b.length) {\n        endB = a.length;\n    }\n    // Create a back-reference for each index\n    //   that should be followed in case of a mismatch.\n    //   We only need B to make these references:\n    const map = Array(endB);\n    let k = 0; // Index that lags behind j\n    map[0] = 0;\n    for (let j = 1; j < endB; j++) {\n        if (b[j] == b[k]) {\n            map[j] = map[k]; // skip over the same character (optional optimisation)\n        }\n        else {\n            map[j] = k;\n        }\n        while (k > 0 && b[j] != b[k]) {\n            k = map[k];\n        }\n        if (b[j] == b[k]) {\n            k++;\n        }\n    }\n    // Phase 2: use these references while iterating over A\n    k = 0;\n    for (let i = startA; i < a.length; i++) {\n        while (k > 0 && a[i] != b[k]) {\n            k = map[k];\n        }\n        if (a[i] == b[k]) {\n            k++;\n        }\n    }\n    return k;\n}\n/**\n * Returns true if the string consistently uses Windows line endings.\n */\nexport function hasOnlyWinLineEndings(string) {\n    return string.includes('\\r\\n') && !string.startsWith('\\n') && !string.match(/[^\\r]\\n/);\n}\n/**\n * Returns true if the string consistently uses Unix line endings.\n */\nexport function hasOnlyUnixLineEndings(string) {\n    return !string.includes('\\r\\n') && string.includes('\\n');\n}\nexport function trailingWs(string) {\n    // Yes, this looks overcomplicated and dumb - why not replace the whole function with\n    //     return string match(/\\s*$/)[0]\n    // you ask? Because:\n    // 1. the trap described at https://markamery.com/blog/quadratic-time-regexes/ would mean doing\n    //    this would cause this function to take O(n²) time in the worst case (specifically when\n    //    there is a massive run of NON-TRAILING whitespace in `string`), and\n    // 2. the fix proposed in the same blog post, of using a negative lookbehind, is incompatible\n    //    with old Safari versions that we'd like to not break if possible (see\n    //    https://github.com/kpdecker/jsdiff/pull/550)\n    // It feels absurd to do this with an explicit loop instead of a regex, but I really can't see a\n    // better way that doesn't result in broken behaviour.\n    let i;\n    for (i = string.length - 1; i >= 0; i--) {\n        if (!string[i].match(/\\s/)) {\n            break;\n        }\n    }\n    return string.substring(i + 1);\n}\nexport function leadingWs(string) {\n    // Thankfully the annoying considerations described in trailingWs don't apply here:\n    const match = string.match(/^\\s*/);\n    return match ? match[0] : '';\n}\n","import Diff from './base.js';\nimport { longestCommonPrefix, longestCommonSuffix, replacePrefix, replaceSuffix, removePrefix, removeSuffix, maximumOverlap, leadingWs, trailingWs } from '../util/string.js';\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nconst extendedWordChars = 'a-zA-Z0-9_\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}';\n// Each token is one of the following:\n// - A punctuation mark plus the surrounding whitespace\n// - A word plus the surrounding whitespace\n// - Pure whitespace (but only in the special case where this the entire text\n//   is just whitespace)\n//\n// We have to include surrounding whitespace in the tokens because the two\n// alternative approaches produce horribly broken results:\n// * If we just discard the whitespace, we can't fully reproduce the original\n//   text from the sequence of tokens and any attempt to render the diff will\n//   get the whitespace wrong.\n// * If we have separate tokens for whitespace, then in a typical text every\n//   second token will be a single space character. But this often results in\n//   the optimal diff between two texts being a perverse one that preserves\n//   the spaces between words but deletes and reinserts actual common words.\n//   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640\n//   for an example.\n//\n// Keeping the surrounding whitespace of course has implications for .equals\n// and .join, not just .tokenize.\n// This regex does NOT fully implement the tokenization rules described above.\n// Instead, it gives runs of whitespace their own \"token\". The tokenize method\n// then handles stitching whitespace tokens onto adjacent word or punctuation\n// tokens.\nconst tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\\\s+|[^${extendedWordChars}]`, 'ug');\nclass WordDiff extends Diff {\n    equals(left, right, options) {\n        if (options.ignoreCase) {\n            left = left.toLowerCase();\n            right = right.toLowerCase();\n        }\n        return left.trim() === right.trim();\n    }\n    tokenize(value, options = {}) {\n        let parts;\n        if (options.intlSegmenter) {\n            const segmenter = options.intlSegmenter;\n            if (segmenter.resolvedOptions().granularity != 'word') {\n                throw new Error('The segmenter passed must have a granularity of \"word\"');\n            }\n            parts = Array.from(segmenter.segment(value), segment => segment.segment);\n        }\n        else {\n            parts = value.match(tokenizeIncludingWhitespace) || [];\n        }\n        const tokens = [];\n        let prevPart = null;\n        parts.forEach(part => {\n            if ((/\\s/).test(part)) {\n                if (prevPart == null) {\n                    tokens.push(part);\n                }\n                else {\n                    tokens.push(tokens.pop() + part);\n                }\n            }\n            else if (prevPart != null && (/\\s/).test(prevPart)) {\n                if (tokens[tokens.length - 1] == prevPart) {\n                    tokens.push(tokens.pop() + part);\n                }\n                else {\n                    tokens.push(prevPart + part);\n                }\n            }\n            else {\n                tokens.push(part);\n            }\n            prevPart = part;\n        });\n        return tokens;\n    }\n    join(tokens) {\n        // Tokens being joined here will always have appeared consecutively in the\n        // same text, so we can simply strip off the leading whitespace from all the\n        // tokens except the first (and except any whitespace-only tokens - but such\n        // a token will always be the first and only token anyway) and then join them\n        // and the whitespace around words and punctuation will end up correct.\n        return tokens.map((token, i) => {\n            if (i == 0) {\n                return token;\n            }\n            else {\n                return token.replace((/^\\s+/), '');\n            }\n        }).join('');\n    }\n    postProcess(changes, options) {\n        if (!changes || options.oneChangePerToken) {\n            return changes;\n        }\n        let lastKeep = null;\n        // Change objects representing any insertion or deletion since the last\n        // \"keep\" change object. There can be at most one of each.\n        let insertion = null;\n        let deletion = null;\n        changes.forEach(change => {\n            if (change.added) {\n                insertion = change;\n            }\n            else if (change.removed) {\n                deletion = change;\n            }\n            else {\n                if (insertion || deletion) { // May be false at start of text\n                    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);\n                }\n                lastKeep = change;\n                insertion = null;\n                deletion = null;\n            }\n        });\n        if (insertion || deletion) {\n            dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);\n        }\n        return changes;\n    }\n}\nexport const wordDiff = new WordDiff();\nexport function diffWords(oldStr, newStr, options) {\n    // This option has never been documented and never will be (it's clearer to\n    // just call `diffWordsWithSpace` directly if you need that behavior), but\n    // has existed in jsdiff for a long time, so we retain support for it here\n    // for the sake of backwards compatibility.\n    if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {\n        return diffWordsWithSpace(oldStr, newStr, options);\n    }\n    return wordDiff.diff(oldStr, newStr, options);\n}\nfunction dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {\n    // Before returning, we tidy up the leading and trailing whitespace of the\n    // change objects to eliminate cases where trailing whitespace in one object\n    // is repeated as leading whitespace in the next.\n    // Below are examples of the outcomes we want here to explain the code.\n    // I=insert, K=keep, D=delete\n    // 1. diffing 'foo bar baz' vs 'foo baz'\n    //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'\n    //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'\n    //\n    // 2. Diffing 'foo bar baz' vs 'foo qux baz'\n    //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'\n    //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'\n    //\n    // 3. Diffing 'foo\\nbar baz' vs 'foo baz'\n    //    Prior to cleanup, we have K:'foo ' D:'\\nbar ' K:' baz'\n    //    After cleanup, we want K'foo' D:'\\nbar' K:' baz'\n    //\n    // 4. Diffing 'foo baz' vs 'foo\\nbar baz'\n    //    Prior to cleanup, we have K:'foo\\n' I:'\\nbar ' K:' baz'\n    //    After cleanup, we ideally want K'foo' I:'\\nbar' K:' baz'\n    //    but don't actually manage this currently (the pre-cleanup change\n    //    objects don't contain enough information to make it possible).\n    //\n    // 5. Diffing 'foo   bar baz' vs 'foo  baz'\n    //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'\n    //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'\n    //\n    // Our handling is unavoidably imperfect in the case where there's a single\n    // indel between keeps and the whitespace has changed. For instance, consider\n    // diffing 'foo\\tbar\\nbaz' vs 'foo baz'. Unless we create an extra change\n    // object to represent the insertion of the space character (which isn't even\n    // a token), we have no way to avoid losing information about the texts'\n    // original whitespace in the result we return. Still, we do our best to\n    // output something that will look sensible if we e.g. print it with\n    // insertions in green and deletions in red.\n    // Between two \"keep\" change objects (or before the first or after the last\n    // change object), we can have either:\n    // * A \"delete\" followed by an \"insert\"\n    // * Just an \"insert\"\n    // * Just a \"delete\"\n    // We handle the three cases separately.\n    if (deletion && insertion) {\n        const oldWsPrefix = leadingWs(deletion.value);\n        const oldWsSuffix = trailingWs(deletion.value);\n        const newWsPrefix = leadingWs(insertion.value);\n        const newWsSuffix = trailingWs(insertion.value);\n        if (startKeep) {\n            const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);\n            startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);\n            deletion.value = removePrefix(deletion.value, commonWsPrefix);\n            insertion.value = removePrefix(insertion.value, commonWsPrefix);\n        }\n        if (endKeep) {\n            const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);\n            endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);\n            deletion.value = removeSuffix(deletion.value, commonWsSuffix);\n            insertion.value = removeSuffix(insertion.value, commonWsSuffix);\n        }\n    }\n    else if (insertion) {\n        // The whitespaces all reflect what was in the new text rather than\n        // the old, so we essentially have no information about whitespace\n        // insertion or deletion. We just want to dedupe the whitespace.\n        // We do that by having each change object keep its trailing\n        // whitespace and deleting duplicate leading whitespace where\n        // present.\n        if (startKeep) {\n            const ws = leadingWs(insertion.value);\n            insertion.value = insertion.value.substring(ws.length);\n        }\n        if (endKeep) {\n            const ws = leadingWs(endKeep.value);\n            endKeep.value = endKeep.value.substring(ws.length);\n        }\n        // otherwise we've got a deletion and no insertion\n    }\n    else if (startKeep && endKeep) {\n        const newWsFull = leadingWs(endKeep.value), delWsStart = leadingWs(deletion.value), delWsEnd = trailingWs(deletion.value);\n        // Any whitespace that comes straight after startKeep in both the old and\n        // new texts, assign to startKeep and remove from the deletion.\n        const newWsStart = longestCommonPrefix(newWsFull, delWsStart);\n        deletion.value = removePrefix(deletion.value, newWsStart);\n        // Any whitespace that comes straight before endKeep in both the old and\n        // new texts, and hasn't already been assigned to startKeep, assign to\n        // endKeep and remove from the deletion.\n        const newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);\n        deletion.value = removeSuffix(deletion.value, newWsEnd);\n        endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);\n        // If there's any whitespace from the new text that HASN'T already been\n        // assigned, assign it to the start:\n        startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));\n    }\n    else if (endKeep) {\n        // We are at the start of the text. Preserve all the whitespace on\n        // endKeep, and just remove whitespace from the end of deletion to the\n        // extent that it overlaps with the start of endKeep.\n        const endKeepWsPrefix = leadingWs(endKeep.value);\n        const deletionWsSuffix = trailingWs(deletion.value);\n        const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);\n        deletion.value = removeSuffix(deletion.value, overlap);\n    }\n    else if (startKeep) {\n        // We are at the END of the text. Preserve all the whitespace on\n        // startKeep, and just remove whitespace from the start of deletion to\n        // the extent that it overlaps with the end of startKeep.\n        const startKeepWsSuffix = trailingWs(startKeep.value);\n        const deletionWsPrefix = leadingWs(deletion.value);\n        const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);\n        deletion.value = removePrefix(deletion.value, overlap);\n    }\n}\nclass WordsWithSpaceDiff extends Diff {\n    tokenize(value) {\n        // Slightly different to the tokenizeIncludingWhitespace regex used above in\n        // that this one treats each individual newline as a distinct tokens, rather\n        // than merging them into other surrounding whitespace. This was requested\n        // in https://github.com/kpdecker/jsdiff/issues/180 &\n        //    https://github.com/kpdecker/jsdiff/issues/211\n        const regex = new RegExp(`(\\\\r?\\\\n)|[${extendedWordChars}]+|[^\\\\S\\\\n\\\\r]+|[^${extendedWordChars}]`, 'ug');\n        return value.match(regex) || [];\n    }\n}\nexport const wordsWithSpaceDiff = new WordsWithSpaceDiff();\nexport function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordsWithSpaceDiff.diff(oldStr, newStr, options);\n}\n","import Diff from './base.js';\nimport { generateOptions } from '../util/params.js';\nclass LineDiff extends Diff {\n    constructor() {\n        super(...arguments);\n        this.tokenize = tokenize;\n    }\n    equals(left, right, options) {\n        // If we're ignoring whitespace, we need to normalise lines by stripping\n        // whitespace before checking equality. (This has an annoying interaction\n        // with newlineIsToken that requires special handling: if newlines get their\n        // own token, then we DON'T want to trim the *newline* tokens down to empty\n        // strings, since this would cause us to treat whitespace-only line content\n        // as equal to a separator between lines, which would be weird and\n        // inconsistent with the documented behavior of the options.)\n        if (options.ignoreWhitespace) {\n            if (!options.newlineIsToken || !left.includes('\\n')) {\n                left = left.trim();\n            }\n            if (!options.newlineIsToken || !right.includes('\\n')) {\n                right = right.trim();\n            }\n        }\n        else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {\n            if (left.endsWith('\\n')) {\n                left = left.slice(0, -1);\n            }\n            if (right.endsWith('\\n')) {\n                right = right.slice(0, -1);\n            }\n        }\n        return super.equals(left, right, options);\n    }\n}\nexport const lineDiff = new LineDiff();\nexport function diffLines(oldStr, newStr, options) {\n    return lineDiff.diff(oldStr, newStr, options);\n}\nexport function diffTrimmedLines(oldStr, newStr, options) {\n    options = generateOptions(options, { ignoreWhitespace: true });\n    return lineDiff.diff(oldStr, newStr, options);\n}\n// Exported standalone so it can be used from jsonDiff too.\nexport function tokenize(value, options) {\n    if (options.stripTrailingCr) {\n        // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n        value = value.replace(/\\r\\n/g, '\\n');\n    }\n    const retLines = [], linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n    // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n        linesAndNewlines.pop();\n    }\n    // Merge the content and line separators into single tokens\n    for (let i = 0; i < linesAndNewlines.length; i++) {\n        const line = linesAndNewlines[i];\n        if (i % 2 && !options.newlineIsToken) {\n            retLines[retLines.length - 1] += line;\n        }\n        else {\n            retLines.push(line);\n        }\n    }\n    return retLines;\n}\n","import React, { useState } from 'react';\nimport { diffLines, diffWords } from 'diff';\nimport '../App.css';\n\nfunction GitHubStyleDiff({ oldText, newText, mode }) {\n  const diff = mode === 'words' ? diffWords(oldText, newText) : diffLines(oldText, newText);\n\n  return (\n    <pre style={{ backgroundColor: '#f6f8fa', padding: '10px', whiteSpace: 'pre-wrap' }}>\n      {diff.map((part, index) => {\n        let color = 'inherit';\n        if (part.added) color = '#d4f8db'; // green\n        else if (part.removed) color = '#fdd'; // red\n\n        return (\n          <span key={index} style={{ backgroundColor: color }}>\n            {part.value}\n          </span>\n        );\n      })}\n    </pre>\n  );\n}\n\nconst DiffEditor = () => {\n  const [text1, setText1] = useState('');\n  const [text2, setText2] = useState('');\n  const [mode, setMode] = useState('words');\n\n  return (\n    <div className=\"app-container\" style={{ padding: '20px', fontFamily: 'Arial' }}>\n      <h2>Difference Editor</h2>\n      <div style={{ display: 'flex', gap: '20px', marginBottom: '20px' }}>\n        <div style={{ flex: 1 }}>\n          <b>Original Text</b>\n          <textarea\n            rows=\"10\"\n            style={{ width: '100%' }}\n            placeholder=\"Enter original text\"\n            value={text1}\n            onChange={(e) => setText1(e.target.value)}\n          />\n        </div>\n        <div style={{ flex: 1 }}>\n          <b>Modified Text</b>\n          <textarea\n            rows=\"10\"\n            style={{ width: '100%' }}\n            placeholder=\"Enter modified text\"\n            value={text2}\n            onChange={(e) => setText2(e.target.value)}\n          />\n        </div>\n      </div>\n\n      <div style={{ marginBottom: '10px' }}>\n        <label>\n          <input\n            type=\"radio\"\n            value=\"lines\"\n            checked={mode === 'lines'}\n            onChange={() => setMode('lines')}\n          />\n          Line Diff\n        </label>\n        <label style={{ marginLeft: '10px' }}>\n          <input\n            type=\"radio\"\n            value=\"words\"\n            checked={mode === 'words'}\n            onChange={() => setMode('words')}\n          />\n          Word Diff\n        </label>\n      </div>\n\n      <h3>Diff Output:</h3>\n      <GitHubStyleDiff oldText={text1} newText={text2} mode={mode} />\n    </div>\n  );\n}\n\nexport default DiffEditor;"],"names":["Diff","diff","oldStr","newStr","callback","options","arguments","length","undefined","oldString","this","castInput","newString","oldTokens","removeEmpty","tokenize","newTokens","diffWithOptionsObj","_a","done","value","postProcess","setTimeout","newLen","oldLen","editLength","maxEditLength","Math","min","maxExecutionTime","timeout","Infinity","abortAfterTimestamp","Date","now","bestPath","oldPos","lastComponent","newPos","extractCommon","buildValues","minDiagonalToConsider","maxDiagonalToConsider","execEditLength","diagonalPath","max","basePath","removePath","addPath","canAdd","addPathNewPos","canRemove","addToPath","exec","ret","path","added","removed","oldPosInc","last","oneChangePerToken","count","previousComponent","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","i","push","Array","from","join","chars","changeObjects","useLongestToken","components","nextComponent","reverse","componentLen","componentPos","component","slice","map","oldValue","longestCommonPrefix","str1","str2","longestCommonSuffix","replacePrefix","string","oldPrefix","newPrefix","Error","concat","JSON","stringify","replaceSuffix","oldSuffix","newSuffix","removePrefix","removeSuffix","maximumOverlap","string1","string2","a","b","startA","endB","k","j","overlapCount","trailingWs","match","substring","leadingWs","extendedWordChars","tokenizeIncludingWhitespace","RegExp","wordDiff","trim","parts","intlSegmenter","segmenter","resolvedOptions","granularity","segment","tokens","prevPart","forEach","part","test","pop","token","replace","changes","lastKeep","insertion","deletion","change","dedupeWhitespaceInChangeObjects","diffWords","ignoreWhitespace","wordsWithSpaceDiff","diffWordsWithSpace","startKeep","endKeep","oldWsPrefix","oldWsSuffix","newWsPrefix","newWsSuffix","commonWsPrefix","commonWsSuffix","ws","newWsFull","delWsStart","delWsEnd","newWsStart","newWsEnd","endKeepWsPrefix","overlap","regex","lineDiff","constructor","super","newlineIsToken","includes","ignoreNewlineAtEof","endsWith","stripTrailingCr","retLines","linesAndNewlines","split","line","GitHubStyleDiff","_ref","oldText","newText","mode","_jsx","style","backgroundColor","padding","whiteSpace","children","index","color","DiffEditor","text1","setText1","useState","text2","setText2","setMode","_jsxs","className","fontFamily","display","gap","marginBottom","flex","rows","width","placeholder","onChange","e","target","type","checked","marginLeft"],"sourceRoot":""}